# Function / Функції

Одразу скажу, що писати код можна і без функцій, але в такому випадку, ти отримаєш дуже багато дублювання коду. Основне завдання функцій - це зберігання коду в певній структурі, яку ти зможеш вснути туди куди тобі потрібно.

Уяви, що в тебе є проект, і в ньому є якісь певні розрахунки, які робляться часто, і в тебе раз за разом використовується наступна формула:

```js
(a + b) / d * c
```

Замість букв, просто потрібно підставляти цифри, і от як би в тебе воно виглядало би в проекті:

```js
// some another code here ...
// ...

const drillingOffset = (10 + 30) / 60 * 89; 
alert('Drilling offset is ' + drillingOffset)

// another code here too ...
// ...

const checkOffset = (70 + 12) / 77 * 12;
alert('Check offset is ' + checkOffset)

// more code here ...
// ...

const finalOffset = (90 + 1212) / 12 * 8;
alert('Final offset is ' + checkOffset)
```

### Проблеми коду, який не використовує функції
Які ключові проблеми можна продемонструвати на цьому приклад:
1. Формула використовується багато де, і по суті всюди вона дублюється;
2. Не зрозуміло, що взагалі ці обрахунки роблять, візьмемо перший приклад, що таке числа 10 і 30? а що таке 60 і 89?
3. Все завжди змінюється, особливо в IT сфері, тому є ризики, що цю формулу в майбутньому потрібно буде змінити, але в даному варіанті, зробити це буде дуже важко, томущо тобі треба буде знайти кожне місце де вона використовується і його міняти, окрім цього ти не зможеш виконати якийсь глобальний пошук, та як в тебе не має ніяких ключових слів, за які ти міг би вхопитися.

### 1. Рішення проблеми організації і зміни формули

Так як функції нам потрібні для того щоб ми могли перевикористовувати код, давай створимо функцію для цієї калькуляції.

Функції створюються за наступним прикладом

```js
function назва_функції() {
  // код в середині функції
}
```

Для нашої задачі це буде виглядати наступним чином:

```js
function calculateOffset() {
  (10 + 30) / 60 * 89
}
```
Ось ми створили нашу функцію, `calculateOffset` - яка буде займатися нашими обрахунками.

На разі ми маємо нашу функцію, вона просто собі існує. Для того щоб виконати код в середині функції, нам потрібно її викликати. Щоб викликати функцію нам потрібно написати її ім'я і круглі дужки
```js
calculateOffset();
```

Не існує ніяких лімітів, скільки разів ми можемо викликати функцію.
```js
calculateOffset();
calculateOffset();
calculateOffset();
calculateOffset();
calculateOffset();
calculateOffset();
...
calculateOffset();
```
Отже, на даному етапі ми вирішили пробелему організації нашого коду, тепер, для нашої формули створенна спеціальна функція і якщо нам щось потрібно буде змінити в нашій формулі, ми просто змінимо її в середині функції. Також частково ми зачепили пробелму дублювання коду, тому що нам не потрібно заново писати формулу, ми просто викликаємо функцію в середині якої є формула.

На разі деякі речі можуть бути не зрозумілими, але ми по шматочках розберемо тему, і можливо буде так, що після прочитання, доведеться ще раз це все перечитати свіжим поглядом


### Вирішення проблеми дублювання і перевикористання
На разі, наша функція працює зі сталими значеннями, для того щоб ми могли перевикористовувати нашу функцію, нам потрібно якимось чином, передавати туди ті числа, які нам потрібні в конкретній ситуації.

**Аргументи функції** - за допомогою них, ми можемо для кожного виклику нашої функції, передавати різні значення.

Аргументи функції передаються під час її виклику, через кому. В якості аргумента може бути будь що, `number`, `string`, `object` і навіть інша функція. Приклад:
```js
calculateOffset(10, 30, 60, 89);
calculateOffset(70, 12, 77, 12);
```
Як ми можемо бачити, ми передаємо в функцію аргументи, через кому, які необхідні для обрахунків, але в мене є 2 питання:

1. Виходить так, що ми можемо передавати все що ми хочемо, і в тому порядку якому ми хочемо, як тоді функція буде розуміти, в яке місце формули, потрібно підставляти потрібне значення?
2. Як ці значення ми можемо отримати в середині функції?

### Як вирішити ці проблеми?
```js
function calculateOffset() {
  console.log(arguments); // Arguments [10, 30, 60, 90];
}

calculateOffset(10, 30, 60, 89);
```
Для кращого розуміння, запусти цей приклад в себе в консольці браузера.

В середині функцій, є така штука, як `arguments`, існує вона тільки і тільки в середині функцій. `arguments` - це псеводомасив, в якому зберігаються всі аргументи, з якими викликалася функція, тобто:

```js
function calculateOffset() {
  console.log(arguments); // Arguments [10, 30, 60, 90];
  
  // Перший аргумент з яким викликалася наша функція
  console.log(arguments[0]); // 10
  // Дргуий аргумент з яким викликалася наша функція
  console.log(arguments[1]); // 30
  // Третій аргумент з яким викликалася наша функція
  console.log(arguments[2]); // 60
  // Четвертий аргумент з яким викликалася наша функція
  console.log(arguments[3]); // 90

  (10 + 30) / 60 * 89
}

                перший (0), другий (1), третій (2), четвертий (3)
calculateOffset(  10,         30,         60,          89   );
```

Отже ми розібралися як ми можемо отримати доступ до аргументів, з якими ми викликали функцію, з цією проблемою ми розібралися. Тепер застосуємо їх для обрахунків, і тут ми стикаємося з іншою проблемою, як бути гарантувати те, що інший розробник буде передавати аргументи в тому порядку, в якому і потрібно, а відповідь - ніяк. Ти ніяк не можеш цього гарантувати, ти можеш зробити якісь натяки на це, створивши для кожного аргумента змінну *цим ми займемося пізніше*, ця відповідальність лягає на того хто використовує функцію. Все що можеш зробити ти - це зробити код таким явним, щоб той розробник, що буде використовувати функцію, зможе по коду зрозуміти що за чим має йти. 

```js
function calculateOffset() {
  const result = (arguments[0] + arguments[1]) / arguments[2] * arguments[3];
  
  console.log(result);
}

calculateOffset(10, 30, 60, 89);
calculateOffset(70, 12, 77, 12);
```

Тепер з допомогою нашої функції, ми можемо передавати різні значення, і отримувати різні результати, і це все та ж сама формула що з початку. Раджу запустити це в браузері і переконатися в цьому.

По суті тепер нам залишилося виправити останню проблему - це очевидність формули, на разі, якщо зайти в код, стає не очевидним, що таке argument[0] чи arguments[3], всі ці числа ж не випадкові, а роблять щось конкретне, це можна легко виправити наступним чином.

```js
function calculateOffset() {
  let interval = arguments[0];
  let oversight = arguments[1];
  let middle = arguments[2];
  let multiplier = arguments[3]
  
  const result = (interval + oversight) / middle * multiplier;
  
  console.log(result);
}

calculateOffset(10, 30, 60, 89);
calculateOffset(70, 12, 77, 12);
```
> Імена для змінних взяті просто з голови, для прикладу.

Якщо подивитися на код зараз, то стає більш зрозуміло, хто що робить, і хто що значить, також ми частково вирішили проблему очевиднності, тепер, інший розробник, зможеш легше зрозуміти, що за чим має йти, наприклад, він зайде в код і побачить, що перший параметр - це інтервал, другий - похибка, третій - середня значення і четвертий множник.

Але, це не зовсім той спосіб, яким ми працюємо з аргументами функції.

### Правильний спосіб працювати з аргументами
Коротше кажучи нам не обов'язоково використовувати псевдомасив arguments, для того щоб отримати доступ до аргументів функції. 

```js
function calculateOffset(interval, oversight, middle, multiplier) {
  const result = (interval + oversight) / middle * multiplier;
  
  console.log(result);
}

calculateOffset(10, 30, 60, 89);
calculateOffset(70, 12, 77, 12);

```
Замість того щоб використовувати псевдомасив arguments, вручну створювати змінні і присвоювати йому необхідне значення з псевдомасива arguments, ми можемо робити це автоматично. Робиться це в `function name(...тут...) {}`. По суті це просто скорочений запис того, що ми робили з argumetns. Для змінної `interval` присвоїться 0 аргумент, для змінної `oversight` - 1 аргумент, для змінної `middle` - 2 аргумент, для змінної `multiplier` - 3 аргумент.

Також такий підхід, ще більше спрощує розуміння того, що і в якому порядку потрібно передавати.

І для закріплення матеріалу, дам ще декілька прикладів

```js
function sayHappyBirthday(firstName, lastName, age) {
  alert('Happy birthday ' + firstName + " " + lastName + " you are " + age + " now.")
}

sayHappyBirthday('John', 'Malkovich', 10);
// в консолі ми отримаємо
// Happy birthday John Malkovich you are 10 now.
```

І ще один, як я казав, функції, можуть приймати будь що завгодно, от що якщо би попердня функція приймала об'єкт? 

```js
function sayHappyBirthday(user) {
  alert('Happy birthday ' + user.firstName + " " + user.lastName + " you are " + user.age + " now.")
}

sayHappyBirthday({
  firstName: 'John', 
  lastName: 'Malkovich',
  age: 10
});
// в консолі ми отримаємо
// Happy birthday John Malkovich you are 10 now.
```

І тут я ще раз хочу зауважити. Якщо дивитися просто на фукнцію, то видно що ми приймаємо тільки один аргумент, але що ми маємо туди передавати, ми не знаємо, для цього щоб це зрозуміти, нам потрібно прочитати код. Після чого ми поймемо, що, перший аргумент повинен бути об'єктом, і в нього повинно бути 3 властивості `firstName`, `lastName` і `age`. Ми ніяк би цього не зрозуміли, не прочитав ши код.

Я це веду до того, що як я казав раніше, відповідальність, за правильну передачу аргументів і порядку, лежить на тому, хто цю функцію буде використовувати, перш за все, він сам повинен зрозуміти, що туди передавати. Ми, як творці цієї функції, мусимо зробити так, що б це було максимально зрозумілим.

### Функції можуть повертати значення
Окрім того, що функції в середині себе можуть щось робити, вони можуть і щось повертати. 

Візьмемо для прикладу функцію, яка рахує площу трапеції, яку нам потім потрібно вивести користувачу.

Для того щоб щось пеовернути з функції, ми використовуємо слово return, після якого пишемо те, що нам потрібно повернути.

```js
function getTrapezoidArea(sideA, sideB, height) {
  const area = (sideA + sideB) / 2 * height;
  
  return area;
}
```

Ось в нас є така функція, якщо щось повертає. В даному випадку, вона повертає значення, яке лежить в середині константи area. Так як ця константа в нас більше ніде не використовується, ми можемо її позбутися.

```js
function getTrapezoidArea(sideA, sideB, height) {
  return (sideA + sideB) / 2 * height;
}
```

Тобто, ми можемо повертати з функції одразу якесь значення, зовсім необов'язково перед цим, записувати його в змінну чи константу.

Але давайте розберомся в загальному, що взагалі означає повернути значення. По-перше, робота з функціями які щось повертають, і які нічого не повертають не відрізняються, приклад внизу:

```js
function getTrapezoidArea(sideA, sideB, height) {
  return (sideA + sideB) / 2 * height;
}

getTrapezoidArea(10, 8, 5);
```

Якщо запустити код, ти побачиш, що не має ніяких помилок. Це все томущо, функції зробленні бути самостійними. От я як функція, думаю таким чином, я повертаю якесь значення, передаю його, якщо ти хочеш, береш його, наприклад записуєш в змінну, не хочеш, ну і хуй з тобою, мені то шо від того.

В прикладі нижче, ми записуємо результат який повертається з функції в константу, і виводимо її для користувача.

```js
function getTrapezoidArea(sideA, sideB, height) {
  return (sideA + sideB) / 2 * height;
}

const trapezoid1 = getTrapezoidArea(10, 8, 5);
const trapezoid2 = getTrapezoidArea(3, 1, 5);
const trapezoid3 = getTrapezoidArea(20, 89, 60);

alert('Area for trapezoid 1 - ' + trapezoid1);
alert('area for trapezoid 2 - ' + trapezoid2)
alert('area for trapezoid 3 - ' + trapezoid3)
```

Ти маєш розуміти ще одну річь, ось ця вся інтерактивність, маю на увазі, коли функція щось повертає, і воно записується десь - це все прописано в лексиці Javascript'а, тобто це не є щось творче, javascript двигун написаний так, щоб розуміти, де фукції, де змінні, де функції які щось вертають, і чи є там якісь змінні перед фукнціями.

Ще як приклад можна зробити взагалі так;

```js
function getTrapezoidArea(sideA, sideB, height) {
  return (sideA + sideB) / 2 * height;
}

alert('Area for trapezoid 1 - ' + getTrapezoidArea(10, 8, 5));
alert('area for trapezoid 2 - ' + getTrapezoidArea(3, 1, 5))
alert('area for trapezoid 3 - ' + getTrapezoidArea(20, 89, 60))
```

Результат не зміниться

### Після ретурна, функція завершує свою роботу
Важливо те, що після того, як ти написав слово `return` фукнція зупинить свою роботу. Для прикладу:

```js
function test() {
  return 'hello world'
  // все що далі, ніколи не буде працювати
  
  console.log('I am after return')
  
  return 'heeey'; // і навіть ще один return не спрацює
}

console.log(test()); // Виведе: 'hello world'
```

Ще одиним цікавим прикладом використання `return` є ситуації, коли тобі треба силою перервати виконання функції. Часто переривання функції таким чином робиться для того, щоб позбутися вкладеності `if else` в середині коду.

Наведу декілька прикладів, як return може допомогти в зменшенні залежості в середині коду і позбутися вкладенності `if else`

```js
function buyAlcohol(alcoholName, age) {
  const shopStore = ['wiski', 'vodka', 'tekilla'];
  
  const alcoholPresentInStore = shopStore.includes(alcoholName);
  
  if (alcoholPresentInStore) {
    if (age >= 18) {
      return 'take your ' + alcoholName + '. Come back.'
    } else {
      console.log('problem: you are too young for this, go home')
    }
  } else {
    console.log('problem: no such alcohol in store')
  }
}

// I got problem cause there are no such alcohol
buyAlcohol('beear', 10);

// I got problem cause I am too young 
buyAlcohol('wiski', 10);

const resultFromFunction = buyAlcohol('vodka', 20);

console.log(resultFromFunction); // Виведе: take your vodka. Come  back.
```

Наче все працює правильно, але виглядає не дуже добре, типу, тобі доведеться лізти і розбиратися, в цих if else каруселях. Є на багато кращий спосіб це вирішити переписавши функцію наступним чином

```js
function buyAlcohol(alcoholName, age) {
  const shopStore = ['wiski', 'vodka', 'tekilla'];
  
  const alcoholPresentInStore = shopStore.includes(alcoholName);

  if (alcoholPresentInStore === false) {
    console.log('problem: no such alcohol in store');
    return;
  }
  
  if (age < 18) {
    console.log('problem: no such alcohol in store')
    return;
  }

  return 'take your ' + alcoholName + '. Come back.'
}
```

Як можна бачити, читати такий код на багато легше, томущо перевірки йдуть одні за одним, і ми з легкістю можемо зрозуміти що взагалі відбувається

### Параметри по замовченню
