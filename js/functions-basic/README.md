# Function / Функції

Функції призначені для того, щоб зменшити дублювання коду, і зробити його більш читаємим і зрозумілим. По своїй суті функція - це структура, яка зберігає певний код, і в будь-який момент код в цій структурі ми можемо запустити, і що саме головне, запустити стільки разів, скільки нам потрібно, тоді коли нам потрібно

Уяви, що в тебе є проект, і в ньому ми часто використовуємо якісь певні розрахунки. Для нашого прикладу я придумав таку от формулу для певних розрахунків:

```js
(a + b) / d * c
```

Замість `a`, `b`, `d` і `c` ми просто будемо підставляти певні цифри. 

```js
// some another code here ...
// ...

const drillingOffset = (10 + 30) / 60 * 89; 
alert('Drilling offset is ' + drillingOffset)

// another code here too ...
// ...

const checkOffset = (70 + 12) / 77 * 12;
alert('Check offset is ' + checkOffset)

// more code here ...
// ...

const finalOffset = (90 + 1212) / 12 * 8;
alert('Final offset is ' + checkOffset)
```

Уявимо, що в нас є от такий код, який використовую цю формулу 3 рази, які проблеми тут можна побачити;
1. Одна й та ж сама формула дублюється в декількох місцях;
2. Не зрозуміло, що означає кожна з цифр, що таке числа `10` і `30`? а що таке `60` і `89`?
3. В випадку, якщо потрібно буде зробити якісь зміни до цієї формули, що трапляється доволі часто, нам буде дуже важко щось в ній змінити, потрібно буде пройтися по всьому нашому коду, читати лінію за лінією і вносити корективи;

Тому розглянемо, як можна виправити ці 3 проблеми використовуючи функції:

### Створення функції 
Функції створюються за наступним прикладом

```js
function назва_функції() {
  // код в середині функції
}
```

Для нашої задачі це буде виглядати наступним чином:

```js
function calculateOffset() {
  (10 + 30) / 60 * 89
}
```
Ось ми створили нашу функцію, `calculateOffset` - яка буде займатися нашими обрахунками. _(Назву я взяв з голови)_

> Зараз наша функція просто зберігає код певний КОНКРЕТНИХ розрахунків, надалі ми зробимо так, щоб ми могли динамічно передавати числа.

Тепер нам потрібно зробити так, щоб код в середині функції виконався, для цього ми повинні викликати функцію:
```js
calculateOffset();
```

Щоб викликати функцію ми пишемо її назву і круглі дужки. Між назвою і дужками не має бути пробілів.

### Як щось передати функцію
На разі основна проблема нашої функції в тому, що вона оперує конкретними значеннями, що по суті не дає нам ніякої переваги, але функції зроблені так, що ми маємо можливість передати туди якісь додаткові данні, коли ми її викликаємо. 

Те що ми передаємо в функцію, називається аргументами.

В якості аргумента може бути будь-який тип данних: `number`, `string`, `object`, `boolean`, `null`, `undefined`. Не має ніякого обмеження за кількістю аргументів, це може бути як 0, так і тисяча, але прийнято передавати не більше 3х аргументів.

> Чому не більше 3х аргументів? Тут все просто, читаємість коду, коли аргументів стає дуже багато, починається путанина що за чим і як, тому це просто правило гарного тону

Ось приклад того, як ми передаємо аргументи, для нашої формули треба 4 числа, тому ми передали 4 аргументи: 
```js
calculateOffset(10, 30, 60, 89);
```
Тут є ще одне правило, перед кожним аргументом повинна бути кома, окрім першого звичайно.

Як використовувати ці числа, ці аргументи в середині функції.
```js
function calculateOffset() {
  console.log(arguments); // 
}

calculateOffset(10, 30, 60, 89);
```
В середині функцій, є така штука, як `arguments`, існує вона тільки і тільки в середині функцій. `arguments` - це об'єкт, в якому зберігаються всі аргументи, з якими викликалася функція. В цього об'єкта в якості ключа число, від 0 до `n`. 

В нашому випадку, ми в функцію передали `4` аргумента, тому, в цьому об'єкті `arguments` буде `4` властивості. Тобто цей об'єкт буде виглядати от так:
```js
{ 
    0: 10,
    1: 30,
    2: 60,
    3: 90 
}
```
Тобто, ключ `0` - зберігає перший аргумент, ключ `1` - другий аргумент, ключ `2` - третій аргумент, ключ `3` - четвертий аргумент

Давай в нашому наступному прикладі виведемо всі ці властивості в консоль, так як ключ в нас - це число, тому ми для доступу до ключа не можемо використовувати `.`, тобто ти не можеш писати так `arguments.0`, ти отримаєш помилку, ти мусиш використовувати квадратні дужки - `arguments[0]`, от так буде все ок.

```js
function calculateOffset() {
  console.log(arguments); 
  
  // Перший аргумент з яким викликалася наша функція
  console.log(arguments[0]); // 10
  // Дргуий аргумент з яким викликалася наша функція
  console.log(arguments[1]); // 30
  // Третій аргумент з яким викликалася наша функція
  console.log(arguments[2]); // 60
  // Четвертий аргумент з яким викликалася наша функція
  console.log(arguments[3]); // 90

  (10 + 30) / 60 * 89
}

                перший (0), другий (1), третій (2), четвертий (3)
calculateOffset(  10,         30,         60,          89   );
```
Ми розібралися з проблемою, як доступатися до аргументів, з якими ми викликали функцію. Тепер ми можемо застосувати їх для формули, і тут ми стикаємося з іншою проблемою, як бути гарантувати те, що інший розробник буде передавати аргументи в тому порядку, в якому і потрібно, та і взагалі буде передавати хоча би якісь аргументи, і з правильним типом данних, а відповідь - **НІЯК**.

Ти ніяк не можеш гарантувати такі речі, ця відповідальність лягає на того хто використовує функцію. Все що можеш зробити ти - це зробити код таким, щоб розробник, який буде використовувати твою функцію, зможе по коду зрозуміти скільки аргументів потрібно передати, який їхній тип має бути, і яких їх порядок.

Тепер давай нарешті використаємо наші аргументи для формули:

```js
function calculateOffset() {
  const result = (arguments[0] + arguments[1]) / arguments[2] * arguments[3];
  
  console.log(result);
}

calculateOffset(10, 30, 60, 89);
```

Тепер все класно, в нас є функція, яка робить нам обрахунки, вона приймає певні параметри, які ми будемо використовувати в нашій формулі. Якщо щось потрібно буде змінити, ми змінимо це в середині функції, а не будемо шукати по всьому коду місце, де це могло б бути

Але на разі, воно не дуже очевидно, я маю на увазі, що таке `arguments[n]`. Давай то просто швидко виправимо, і для кожного аргумента створимо змінну, тоді по назві змінній можна буде поняти що кожний аргумент означає, і для інших розробників, буде більш очевидно, що в якому порядку передавати.

```js
function calculateOffset() {
  let interval = arguments[0];
  let oversight = arguments[1];
  let middle = arguments[2];
  let multiplier = arguments[3]
  
  const result = (interval + oversight) / middle * multiplier;
  
  console.log(result);
}

calculateOffset(10, 30, 60, 89);
```
> Імена для змінних взяті просто з голови, не шукай в них логіки.

Якщо подивитися на код зараз, то стає більш зрозуміло, хто що робить, і хто що значить. І постав себе не місце іншої людини, скажи ж, тобі було би ліпше дивитися на цей приклад, ні ж на попередній, так як просто по назві, ти одразу зрозумієш, що це і нащо. 

### Зручний спосіб роботи з аргументами 
Якщо чесно, `arguments` - це не те що ми використовуємо в повсякденному житті, але розуміння цього терміну, дуже і дуже важливе, бо наступне, про що я буду говорити, під капотом використовує саме `arguments`.

```js
function calculateOffset(interval, oversight, middle, multiplier) {
  const result = (interval + oversight) / middle * multiplier;
  
  console.log(result);
}
                |interval - arguments[0]| |oversight - arguments[1]| |middle - arguments[2]| |multiplier - arguments[3]|
                 -----------------------   ------------------------  ----------------------  --------------------------
calculateOffset(|        10,            | |         30,            | |        60,          | |             89          |);

calculateOffset(10, 30, 60, 89); // це я просто здублював те що на строку вище, просто щоб було понятніше і видніше
```
Цей приклад, абсолютно ідентичний до попереднього, але розберемося:

1. Ти викликав нашу функцію і передав 4 аргумента `calculateOffset(10, 30, 60, 89);`
2. В середині нашої функції, в круглих дужках ми оголошуємо змінні, через кому, в нашому випадку ми оголосили 4 змінних: `interval`, `oversight`, `middle`, `multiplier`
3. Якщо перед цим, ми вручну створювали змінні, і вручну для цих змінних присвоювали потрібний аргумент з об'єкта `arguments`, функція це зробить заімсть тебе, і для кожної змінної, присвоїть потрібний `arguments`, тобто для `arguments[0]` присвоїть першу змінну, в нашому випадку це `interval`, для `arguments[0]` присвоїть другу змінну, в нашому випадку це `oversight` і так далі по черзі

Також такий підхід, ще більше спрощує розуміння того, що і в якому порядку потрібно передавати.

І для закріплення матеріалу, дам ще декілька прикладів

```js
function sayHappyBirthday(firstName, lastName, age) {
  console.log(firstName); // "John"
  console.log(lastName); // "Malkovich"
  console.log(age); // 10
}

sayHappyBirthday('John', 'Malkovich', 10);
```

Як я казав раніше, в аргументи функції, ми можемо передавати будь що завгодно, давай замість того щоб передавти 3 аргумента, передамо один, в якому буде об'єкт користувача:

```js
function sayHappyBirthday(user) {
  console.log(user.firstName); // "John"
  console.log(user.lastName); // "Malkovich"
  console.log(user.age); // 10
}

sayHappyBirthday({
  firstName: 'John', 
  lastName: 'Malkovich',
  age: 10
});
```
Як можеш бачити, все працює без проблем

І тут я ще раз хочу зауважити. Якщо дивитися просто на фукнцію, то видно що ми приймаємо тільки один аргумент, але що ми маємо туди передавати, і щоб вияснити це, нам потрібно розібрати код в середині функції. Після чого ми поймемо, що, перший аргумент повинен бути об'єктом, і в нього повинно бути 3 властивості `firstName`, `lastName` і `age`. Ми ніяк би цього не зрозуміли, не прочитав ши код.

Я це веду до того, що як я казав раніше, відповідальність, за правильну передачу аргументів і порядку, лежить на тому, хто цю функцію буде використовувати, перш за все, він сам повинен зрозуміти, що туди передавати. Ми, як творці цієї функції, мусимо зробити так, що б це було максимально зрозумілим.

### Функції можуть повертати значення
Окрім того, що функції в середині себе можуть щось робити, вони можуть і щось повертати, давати якийсь результат свого виконання. 

Створимо функцію, яка рахуватиме площу трапеції, і ми будемо повертати цю площу, як результат виконання функції

Щоб повернути щось з функції, ми використовуємо слово `return`, після якого, через пробіл пишемо значення, яке будемо повертати.

```js
function getTrapezoidArea(sideA, sideB, height) {
  const area = (sideA + sideB) / 2 * height;
  
  return area;
}
```

Ми рахуємо площу, записуємо її в константу, і повертаємо значення константи. Але ця константа в нас більше ніде не використовується, і ми можемо позбутися від неї:

```js
function getTrapezoidArea(sideA, sideB, height) {
  return (sideA + sideB) / 2 * height;
}
```

Тобто, ми можемо повертати з функції одразу якесь значення, зовсім необов'язково перед цим, записувати його в змінну чи константу.

Але треба зрозуміти, що взагалі означає повернути значення. По-перше, функції які щось повертають, і які нічого не повертають працюють по тому самому принципу, приклад внизу:

```js
function getTrapezoidArea(sideA, sideB, height) {
  return (sideA + sideB) / 2 * height;
}

getTrapezoidArea(10, 8, 5);
```

Функції зробленні бути самостійними, я як функція, думаю таким чином: "я повертаю (віддаю) якесь значення, якщо ти хочеш, бери його, записуй в змінну, передавай ще кудись, мені без різниці будеш ти якось використовувати значення, яке я повертаю, чи ні, мені від того ні холодно ні жарко". 

Локальний приклад, це як сварочний апарат з факторки, ти йому передаєш аргументи, залізо, воно тобі робить шестерні, і повертає їх (віддає), і це вже твоє рішення, будеш ти їх забирати звідти, чи не будеш. 

В прикладі нижче, ми записуємо результат який повертається з функції в константу, і виводимо її для користувача.

```js
function getTrapezoidArea(sideA, sideB, height) {
  return (sideA + sideB) / 2 * height;
}

const trapezoid1 = getTrapezoidArea(10, 8, 5);
const trapezoid2 = getTrapezoidArea(3, 1, 5);
const trapezoid3 = getTrapezoidArea(20, 89, 60);

alert('Area for trapezoid 1 - ' + trapezoid1); // 45
alert('area for trapezoid 2 - ' + trapezoid2); // 10
alert('area for trapezoid 3 - ' + trapezoid3); // 3270
```

Ти маєш розуміти ще одну штуку, ось ця вся інтерактивність, маю на увазі, коли функція щось повертає, і воно записується наприклад в змінну - це все прописано в лексиці Javascript'а, тобто це не є щось творче, javascript двигун написаний так, щоб розуміти що відбувається. Якщо він бачить, що ти намагаєшся для змінної присвоїти виклик функції, він це зрозуміє, і присвоїть для цієї змінної те, що поверне ця функція.

Ще як приклад можна зробити взагалі так;

```js
function getTrapezoidArea(sideA, sideB, height) {
  return (sideA + sideB) / 2 * height;
}

alert('Area for trapezoid 1 - ' + getTrapezoidArea(10, 8, 5));   // 45
alert('area for trapezoid 2 - ' + getTrapezoidArea(3, 1, 5));    // 10
alert('area for trapezoid 3 - ' + getTrapezoidArea(20, 89, 60)); // 3270
```

Результат не зміниться

### Після `return`, функція завершує свою роботу
Важливо те, що після того, як ти написав слово `return` фукнція зупинить свою роботу. Для прикладу:

```js
function test() {
  return 'hello world'
  // все що далі, ніколи не виконається 
  
  console.log('I am after return')
  
  return 'heeey'; // і навіть ще один return не спрацює
}

console.log(test()); // Виведе: 'hello world'
```

### Аргументи по замовчуванню
Можна зробити так, щоб якщо користувач не передав якийсь з аргументів, присвоювати для нього значення по замовчуванню. Робиться це наступним чином

```js
function sayHappyBirthday(firstName, lastName='surname', age=0) {
  console.log(firstName); // "John"
  console.log(lastName); // surname
  console.log(age); // 0
}

sayHappyBirthday('John');
```

В цьому прикладі, ми викликали функцію, тільки з одним аргументом, в той час як в функції, ми створюємо 3 змінних, для 3х аргументів. 

Для змінної `lastName` і `age` ми через знак присвоєння вказали значення, які будуть використовуватися в випадку, якщо їх не передадуть.
