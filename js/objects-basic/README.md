# Основи об'єктів
Об'єкт - це тип данних в Javascript, що дозволяє тобі зберігати данні у вигляді ключ значення. Часто використовуються коли необхідно об'єднати щось спільне в середині однієї структури.

Розберемо такий приклад
```js
const firstName = 'John';
const lastName = 'Carter';
const age = 15;
```

Ми створили 3 константи, в яких зберігаємо данні користувача. Всі ці 3 константи стосуються якогось конкретного користувача, тоді чому би нам не об'єднати їх, для цього, ми можемо використати об'єкт;

```js
const user = {
  firstName: 'John',
  lastName: 'Carter',
  age: 15
}
```

Для того, щоб створити об'єкт ми пишемо фігурні дужки `{}`, де ми зберігаємо `властивості` об'єкта у вигляді `ключ: значення`. Ключі існують для того, щоб доступатися до значень. В цьому об'єкті в нас є 3 ключі, а саме `firstName`, `lastName` і `age`.

Для того, щоб доступитися до якогось певного ключа і витягнути його значення ми використовуємо крапку `.`.

```js
const user = {
  firstName: 'John',
  lastName: 'Carter',
  age: 15
}

console.log(user.firstName); // "John"
console.log(user.lastName); // "Carter"
console.log(user.age); // 15
```

В даному прикладі ми вивели в консоль кожну властивість об'єкта.

Окрім того, ми можемо доступатися використовуючи квадратні дужки `[]`, але тоді в ці дужки нам потрібно передавати назву ключа у вигляді строки

```js
const user = {
    firstName: 'John',
    lastName: 'Carter',
    age: 15
}

console.log(user['firstName']); // "John"
console.log(user['lastName']); // "Carter"
console.log(user['age']); // 15
```

Результат не зміниться. Але от питання, навіщо нам це? Типу, ми ж і так можемо доступатися через крапку. Доступ до властивості об'єкта через `[]` потрібен через декілька можливих випадків

1. **Ключ об'єкта має пробіл**
   ```js
    const user = {
        'first name': 'John',
        'last name': 'Carter',
        age: 15
    }

    console.log(user['first name']); // "John"
    console.log(user['last name']); // "Carter"
    console.log(user.age); // 15
    ```
   По-перше, якщо ти хочеш, щоб ключ об'єкта мав пробіл, ти зобов'язаний огорнути його в лапки _(2га і 3тя лінія)_. Ну і як можеш бачити, коли ми виводимо в `console.log` властивість, ми використовуємо квадратні дужки, щоб мати можливість вивести ключ з пробілом.
2. **Ключ об'єкта знаходиться в середині змінної.** Такі випадки існують, в подальших темах я навіть покажу як це можна використовувати. 
   ```js
   const firstNameKey = 'firstName';
   const lastNameKey = 'lastName';
   
    const user = {
        firstName: 'John',
        lastName: 'Carter',
        age: 15
    }

    console.log(user[firstNameKey]); // "John"
    console.log(user[lastNameKey]); // "Carter"
    console.log(user.age); // 15
    ```
    По суті, ти так само передав строку, як і в попередніх двох прикладах, просто зараз вона знаходиться в середині константи

Окрім того є ще одна прикольна штука. Ти можеш створити об'єкт, ключ якого буде лежати в середині змінної, дивись що маю на увзі

```js
const firstNameKey = 'firstName';
const lastNameKey = 'lastName';

const user = {
    [firstNameKey]: 'John',
    [lastNameKey]: 'Carter',
    age: 15
}

console.log(user.firstName); // "John"
console.log(user.lastName); // "Carter"
console.log(user.age); // 15
```

Якщо подивитися в консоль, то можна побачити, що все працює як і раніше. Що ж тут відбувається. Замість того щоб написати просто ключ об'єкта як ми то робили раніше, ми відкрили квадратні дужки `[]`, і в даному випадку, ми вставили сюди константи, які зберігають певну строку, і ця строка буде використанна для назви ключа.

### Доступ до властивості, що не існує
Якщо ти будеш звертатися до властивості, якої не має в об'єкті, ти отримаєш `undefined`.

```js
const user = {
  firstName: 'John',
  lastName: 'Carter',
  age: 15
}

console.log(user.firstName); // "John"
console.log(user.lastName); // "Carter"
console.log(user.age); // 15
console.log(user.hello); // undefined
console.log(user.who); // undefined
```

В цьому прикладі ми намагалися звернутися до властивостей `hello` та `who` яких не має в нашому об'єкті, тому в консоль вивелося `undefined`.

### Зміна об'єкта
Ми можемо змінювати властивості об'єкта, це робиться дуже просто, ми просто доступаємося до властивості об'єкта, пишемо знак присвоєння `=` і нове значення:

```js
const user = {
  firstName: 'John',
  lastName: 'Carter',
  age: 15
}

user.firstName = 'Karl';
user['age'] = 29;

console.log(user.firstName); // "Karl"
console.log(user.lastName); // "Carter"
console.log(user.age); // 20
```

### Видалення властивостей
Для видалення властивості об'єкта, ми робимо наступне. Пишемо слово `delete` і доступаємося до властивості яку нам потрібно видалити;
```js
const user = {
  firstName: 'John',
  lastName: 'Carter',
  age: 15
}

delete user.firstName;
delete user.age;

console.log(user.firstName); // undefined 
console.log(user.lastName); // "Carter"
console.log(user.age); // undefined
```

### Вкладений об'єкт
В об'єкті ми можемо зберігати будь-які значення, навіть об'єкт
```js
const user = {
  firstName: 'John',
  lastName: 'Carter',
  age: 15,
  address: {
    city: "Copenhagen",
    country: "Denmark"
  }
}

console.log(user.firstName); // "John"
console.log(user.address.city); // "Copenhagen"
console.log(user.address['country']); // "Denmark"
```
В нашому прикладі, наш об'єкт `user` має властивість `address` значення якої є об'єкт. І зверни увагу, що коли ми виводимо ці значення в консоль, ми доступаємося до них таким самим чином як до звичайного об'єкта, не вкладеного. По суті, ти звертаєшся до об'єкта `user` потім звертаєшся до його властивості `address` що також є об'єктом, і тут діють всі ті ж самі правила

### Reference Value / посилання
В Javascript є таке поняття як примітивні значення і значення по посиланню, об'єкти - це якраз і є значення по посиланню, в той час як всі інші `number`, `string`, `boolean`, `null`, `undefined` - це примітивні значення.

В чому різниця: якщо ти в змінну записуєш примітив, наприклад строку, змінна буде зберігати значення, тобто строку, але якщо ти запишеш ссилочне значення, тобто об'єкт, вона буде зберегіти не об'єкт, а посилання на цей об'єкт, після чого трапиться прикольна штука.

```js
const first = {
  name: 'First object'
}

const second = first;

second.name = 'Second object'

console.log(second.name); // Second object
console.log(first.name); // Second object
```

Ми створили константу `first` і присвоїли їй об'єкт, потім ми створили константу `second` і присвоїли їй значення константи `first`. Після чого ми змінили властивість `name` в константи `second`. І в консолі ми можемо бачити, що змінилася і константа `first`.

На справді, в цьому не має нічого дивного і важкого, але розберемося детальніше. Коли ти створюєш об'єкт, в нашому випадку це те, що ти робиш для константи `first`, цей об'єкт створюється десь оперативній пам'яті, а в константу `first` присвоюється посилання на цей об'єкт, посилання це як в інтернеті, ссилка на сайт, так і тут, ссилка на цей об'єкт в пам'яті.

І коли ми написали: `const second = first;`, ми для константи `second` присвоїли не сам об'єкт, а посилання на цей об'єкт. І що виходить, в нас є 2 константи, які посилаються на один і той самий об'єкт. І виходить що логічно, якщо `second` і `first` мають посилання на один і той самий об'єкт, якщо ти щось зміниш використовуючи константу `second` чи `first` ти будеш міняти один і той самий об'єкт, і коли ти будеш виводити ти будеш виводити один і той самий об'єкт, томущо в них одинакові посилання.

В Javascript є методи, як ти можеш скопіювати сам об'єкт, а не просто посилання, але керуючися нашими нинішніми знаннями, якщо ти хочеш мати копію об'єкта `first`, тобі треба зробити наступне

```js
const first = {
  name: 'First object'
}

const second = {
  name: first.name
};

second.name = 'Second object'

console.log(second.name); // Second object
console.log(first.name); // First object
```

В такому випадку всьо буде ок, бо ми створили новий об'єкт.
