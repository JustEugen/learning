# Основи масивів
Перш ніж ми розберемо масиви, я наведу декілька прикладів, навіщо вони взагалі потрібні. Якщо робити аналогію з життям, то масиви ми використовуємо дуже і дуже часто, для прикладу книжка, з певної сторони її можна сприймати як масив сторінок, де кожна сторінка має свій номер, список покупок, де в тебе просто є набір товарів, які йдуть в певному порядку один за одним. 

Чому масиви це так необхідно? Уявимо, що наш додаток повинен зберігати списком продуктів, які нам потрібно купити в магазині, кожен продукт нам треба десь записати, а для того щоб щось зберегти, ми використовуємо змінні, або константи.
```js
const product0 = 'apple';
const product1 = 'orange';
const product2 = 'beer';
const product3 = 'potato';
```
Тут ми зберігаємо 4 продукти, і для кожного продукту нам доводиться робити константу, але що робити у випадку якщо ми не знаємо скільки продуктів може бути в списку на покупки, або цей список може змінюватися, в один день це може бути 4, в інший 20, а в ще інший 2. А якщо ми захочемо зробити так, щоб користувач міг додавати продукти в реальному часі, як тоді їх зберігати? 

Якраз для розв'язання таких проблем, і існують масиви, але спочатку трохи теорії.

Якщо в загальному, то масив - це **структура данних**, яка зберігає данні у вигляді списку, де кожний елемент списку має свій порядковий номер, починаючи з `0`, тобто, перший елемент буде мати номер `0`, другий елемент буде мати номер `1` і так по черзі.

**Javascript** доволі сильно відрізняється від інших мов програмування, і на відміну від інших мов, масив тут - це спеціальний вид об'єкта. Якщо говорити простіше, розробники `Javascript` створили тип данних `Object`, і на основі цього типу, вони створили спеціальний вид об'єкту як `Array` (масив) який по перше - перйняв весь функціонал об'єктів, по друге - на основі цього функціоналу додав свій, який спрощує нам роботу зі списками (під списком мається на увазі те, що ми розбирали на параграф вище).

На відміну від об'єктів де у якості ключа може бути `string` або `number`, в масивах у якості ключа може бути тільки `number`, **в масивах це число ми називаємо `index` (укр. індекс).** 

> Ще раз повторю `index` - це просто порядковий номер елемента масиву від `0` до `n`. Перший елемент масиву буде мати індекс `0`, другий елемент індекс `1` і так далі.

Але тут треба розуміти, масив - це надбудова над об'єктом не на рівні мови, а на рівні самого Javascript рушія, тому масиви мають свій синтаксис створення.

> Коли я кажу "не на рівні мови" я маю на увазі, що використовуючи Javascript  ми не можемо повністю відтворити функціонал масивів, томущо деякі речі вписані в сам рушій, зі своєю лексикою створення і так далі. 


Тут такий міні перерив. Те що було описано вище, це загальна теорія про масиви, яку насправді багато хто не знає, або не розуміє, деякі речі ти зараз не зрозумієш, але частково ми розберемо їх тут, частково в практиці.

Перша перевага масивів, у роботі з списками, перед об'єктами, це те, що масив автоматично проставляє індекс для кожного елементу масив. Для прикладу, використовуючи об'єкт, створимо нумерований список.
```js
const products = {
  0: 'apple',
  1: 'organe',
  2: 'berer',
  3: 'potato'
}
```
Ось ми створили об'єкт, де кожний продукт, має свій номер. Виведемо кожний продукт в консоль. Щоб вивести властивість об'єкта, в якого у якості ключа `number`, ми повинні використовувати квадратні дужки `[]`
```js
const products = {
  0: 'apple',
  1: 'organe',
  2: 'berer',
  3: 'potato'
}

console.log(products[0]); // 'apple'
console.log(products[1]); // 'orange'
console.log(products[2]); // 'beer'
console.log(products[3]); // 'potato'
```

Перша важкість, яку я бачу це те, що ми повинні самі проставляти порядковий номер для кожної властивості, типу, тут в нас 4 елементи, це не так багато, але що якщо в нас буде 100 елементів? не порядок.

Масиви ж, спрощують нам цю роботу, для початку просто створимо масив.

Щоб створити масив, ми спочатку оголошуємо `const` або `let`, далі після оператора присвоєння `=` відкриваємо квадратні дужки `[]`. Елементи масиву ми перераховуємо через кому `,`.

**Ось приклад масиву з `4` елементів:**
```js
const products = ['apple', 'orange', 'beer', 'potato'];
```
Як можеш бачити між кожним елементом ми ставимо кому, окрім останнього.

**А ось масив з одним елементом:**
```js
const products = ['tomato'];
```
**А ось пустий масив:**
```js
const products = [];
```

### Індекси
Перша проблема яку ми знайшли - це те, що нам самим треба проставляти порядковий номер, масиви це роблять самі.
```js
                     0        1        2        3
const products = ['apple', 'orange', 'beer', 'potato'];
```
В цьому масиві в нас є 4 елементи:
- Для 1-го елемента буде присвоєний індекс / ключ `0` і значення - `apple`
- Для 2-го елемента буде присвоєний індекс / ключ `1` і значення - `orange`
- Для 3-го елемента буде присвоєний індекс / ключ `2` і значення - `beer`
- Для 4-го елемента буде присвоєний індекс / ключ `2` і значення - `potato`

Як я і казав, масив це просто надбудова над об'єктом, індекс в масиві / порядковий номер - це те ж саме що і ключ в об'єкті, тому виводиться це все таким самим чином як в прикладі з об'єктом
```js
                     0        1        2        3
const products = ['apple', 'orange', 'beer', 'potato'];

console.log(products[0]); // 'apple'
console.log(products[1]); // 'orange'
console.log(products[2]); // 'beer'
console.log(products[3]); // 'potato'
```

Ти вже можеш бачити величезну різницю в тому як би нам довелося паритися, як би ми не мали масивів, а мали лише прості об'єкти.

### Доступ до не існуючих елементів
Якщо ти пам'ятаєш, якщо ми намагалися вивести властивість об'єкта, якої не існує в цьому об'єкті, то ми отримували `undefined`.
```js
const o = {
  name: 'John'
}

console.log(o.name); // 'John'
console.log(o.age); // undefined
```
Так як масиви - це те ж саме що і об'єкти, якщо ти будеш намагатися отримати не ісунючий елемент масиву, ти також отримаєш `undefined`.
```js
const products = ['apple', 'orange', 'beer', 'potato'];

console.log(products[4]); // undefined
console.log(products[5]); // undefined
console.log(products[6]); // undefined
console.log(products[7]); // undefined
```
В масиві `products` `4` елементи, і найбільший індекс - це `3` _(3 а не 4, тому що ми рахуємо індекси з 0)_, а якщо ти будеш звертатися до індексу `4` і більше, ти по суті будеш звертатися до властивостей об'єкта яких не існує, тому ти також отримуєш `undefined`


### Що ми можемо зберігати в середині масиву? 
Так як масив це всього лиш надбудова над об'єктом тут діють ті ж самі правила. В об'єкті, в якості значення ключа ми могли зберігати будь-який тип данних, так і тут так само.
```js
                     0     1    2        3           4             5            6          7
const products = ['apple', 10, null, { age: 10 }, undefined, function hi() {}, true, ['orange', 938]];


console.log(products[0]); // 'apple'
console.log(products[1]); // 10
console.log(products[2]); // null
console.log(products[3]); // { age: 10 }
console.log(products[4]); // undefined
console.log(products[5]); // function hi() {}
console.log(products[6]); // true
console.log(products[7]); // ['orange', 938]

// і тут трохи цікавіше, якщо пам'ятаєш, ми в темі про об'єкти розглядали вкладені об'єкти
// якщо ніт, то краще візь і кинь оком саме на ту під тему
// тут така ж сама фігня, масив - це об'єкт, і тут в нас виходить така ж сама ситуація
// спочатку ми доступаємося до останнього елемента масива products використовуючи products[8]
// а в середині цього елемента також масив, і на далі ми вже доступаємося до цього внутрішнього масиву
console.log(products[8][0]); // 'organge'
console.log(products[8][1]); // 938'
```

В масиви дуже легко додавати нові значення (ми це розглянемо тут пізніше), тому іноді, ми створюємо пустий масив, і по ходу виконання коду щось туди додаємо. 

### Довжина масиву
Тут ми ще ближче підбираємося до відповіді, чому для списків використовувати об'єкти це погана затія, і чому існує така штука як масив. 

От уявимо що в нас не має масивів, а є тільки об'єкти, і в об'єкті мм зберігаємо список продуктів, і нам треба мати можливість дізнатися скільки в загальному продуктів знаходиться в цьому списку. В об'єктах, не має функціоналу, який дозволяє тобі отримати кількість властивостей, потрібно перебрати весь об'єкт і рахувати (як перебирати об'єкт ми потім розглянемо), але от уяви що в тебе в об'єкті дуже багато продуктів, і перебирато його кожного разу не найкраще рішення.

Як варіант ми можемо зберігати додаткову властивість, назвемо її `count`, і в неї будемо вписувати загальну кількість продуктів

```js
const products = {
  0: 'apple',
  1: 'organe',
  2: 'berer',
  3: 'potato',
  count: 4
}
```

Але є одна біда, якщо ми будемо міняти цей об'єкт, наприклад додамо ще один продукт, нам треба буде вручну міняти цю властивість `count`.

```js
const products = {
  0: 'apple',
  1: 'organe',
  2: 'berer',
  3: 'potato',
  count: 4
}

products[4] = 'kiwi'
products.count = products.count + 1;
```

Я думаю ти бачиш, що це прям дуже незручно, і можна легко провтикати, і купа інших нюансів.

Крутизна масивів в тому, що якщо ти додаєш елемент, чи забираєш, він по перше, автоматично міняє його дожину, по друге, якщо ти наприклад видалиш елемент з індексом `0`, то використовуючи об'єкт тобі треба буде зменшити індекс всіх наступних елементів на 1, а от масив зробить це сам.


**Перш за все, як отримати довжину масиву?**

Так як масив - це надбудова над об'єктом, він має вбудовані властивості, один з них - це `length`, в ньому зберігається довжина масива

```js
const products = ['apple', 'orange', 'beer', 'potato'];

console.log(products.length); // 4
```

А для того, щоб, наприклад додати в кінець масиву елемент, в середині масив є метод `push`. Він приймає один аргумент - це значення яке ти хочеш впихнути в кінець масива

> Метод - це просто властивість, де в якості значення використовується функція
> ```js
> const user = {
>   firstName: "John",
>   lastName: "Carter",
>   getFullName: function() {
>     return 'John Carter';
>   }
> ```
> Як можеш бачити, тут є властивість `firstName`, `lastName` і метод `getFullName` - функція що повертає повне ім'я

```js
const products = ['apple', 'orange', 'beer', 'potato'];

console.log(products.length); // 4

products.push('kiwi');

console.log(products.length); // 5
console.log(products[4]); // kiwi
console.log(products); // ['apple', 'orange', 'beer', 'potato', 'kiwi']
```

Як ти можеш бачити метод `push` додав в кінець масиву елемент, надав для нього потрібний індекс, тобто `4` (так як перед тим як ми додали цей елемент, в масиві в нас було всього лиш 4 елементи, тобто останній індекс був 3, а коли в масиві стало 5 елементів, останній індекс має бути 4), і оновив довжину масиву, тобто властивість `length`

От є в тебе твій масив products, який зберігає продукти.






---------


Масиви, як і об'єкти круті тим, що до них доступ дуже і дуже швидкий, що я маю на увазі. Якщо ти знаєш `index` елемента, якщо говорити про масиви, або `ключ` об'єкта, якщо говорити про об'єкти, ти можеш використати їх щоб доступитися напряму, до конкретного елемента, чи конкретної властивості. Тобто тобі не треба проходитися по всьому об'єкті чи по всьому масиві, щоб знайти чи щось дістати.
