# Scope

Scope (зона видимості) - це спеціальний об'єкт, в якому зберігаються всі змінні та функції, які були оголошені. Ми не можемо побачити йог візуально, томущо це потрібно суто для javascript рушія. Scope ще інколи називають lexical environment (лексичне оточення).

Для чого він взагалі потрібен?

```js
let animal = 'cat';

console.log(animal);
```

В цьому прикладі, в нас є змінна `animal`, яку ми потім виводимо в `console.log`. І тут виникає питання, а як javascript рушій, коли буде виконувати код, буде знати, що це за змінна, та де її шукати? Тут якраз на допомогу приходить `scope`. Якщо під час виконня коду, Javascript двигун натикається на створення змінної записує її в `scope`, тобто в нього є спеціально відведенне місце, в якому він зберігає данні про всі змінні які були створені, і якщо йому треба буде доступитися до якоїсь змінної, він завжди буде знати, де її шукати.

Але є 3 рівня scope:
- глобальний / global
- блочний / block
- локальний / local / function scope

### Глобальний scope
Глобальний скоуп охоплює всю html сторінку.

Для прикладу

```html
<body>
    <script>
      let myTestVariable = 'hello world';
    </script>
    <script>
      console.log(myTestVariable)
    </script>
</body>
```

Якщо запустити цей приклад, то ми побачимо, що в конолі виведиться 'hello world'. Хоч це і 2 різних скрипта, але вони все одно ділять один глобальний скоуп. Раніше таким чином підключалися різні бібліотеки

```html
<body>
    <script src="https://some-libray.com/code"></script>
    <script src="https://another-libray.com/code"></script>
    <script>
      // і тут ми маємо доступ до змінних які були оголошені в середині біліотек вище.
    </script>
</body>
```

Також ще один приклад того, як це виглядало би, як би наш javascript був би в різних файлах.

Структура

```
/my-project 
    |- index.html
    |- first.js
    |- second.js
```

first.js
```js
const userName = 'John';
```

second.js
```js
console.log(userName); // 'John'
```

index.html
```html
<body>
    <script src="./first.js"></script>
    <script src="./second.js"></script>
</body>
```

Але ти можеш розуміти, що якщо ти орагнізовуєш код таким чином, то ти повинен підключати скрипти в правильному порядку. Томущо, якщо ти підключиш спочатку `./second.js` а вже потім `./first.js`, то тоді в `./second.js` при спробі вивести змінну `userName` ти отримаєш помилку, томущо на той момент, скрипт `./first.js`, в якому ця змінна створюється, не виконався, і такої змінної в скрипті `./second.js` просто не існує.

### Локальний scope / функційний scope
Цей вид скоупу стоворюється для кожної функції.

```js
function sayHello() {
  let test = 'I am inside function';
  
  console.log(test)
}

sayHello();
```

Розглянемо цей приклад:
1. Для функції `sayHello` буде створенний свій власний scope;
2. Змінна `test` буде записана в scope функції `sayHello`;
3. Коли ми викликаємо `console.log` ми використовуємо змінну `test`, тому javascript рушій почне шукати, чи є така змінна в середині скоупу цієї функції, в нашому випадку така змінна є, і в консоль нам виведеться: 'I am inside function'

### Блочний scope / block scope
Тут все простіше. Блочний scope існує в середині тіла if else, while, do while, for, try catch і працює він тільки для `let` та `const`, `var` блочинй скоуп ігнорує, і створюється або в глобальному, або в локальному.

Прикладами:
```js
if (true) {
  let hello = 'test variable'; // змінна створенна в середині блока if, і доступна тільки в середині цього блоку.
}

// Error. тут ми отримаємо помилку,
// тому що в даному скоупі такої змінної як hello не має
console.log(hello);
```

```js
for (let i = 0; i < 10; i++) {
  let someVariable = 'I am variable';
}

// Error. Якщо ми будемо намагатися доступитися до змінної someVariable
// ми отримаємо помилку, томущо в поточному скоупі такої
// змінної не має
console.log(someVariable);

// Error. Це також стосується і змінної i, томущо вона також була створенна середині блоку for.
console.log(i);
```

А от з `var` ситуація зовсім інша. Зайду на перед, відсутність у `var` розуміння блочного скоупу і сталол причиною того, що вони перестали використовуватися.

```js
if (true) {
  var hello = 'I am var';
}

console.log(hello); // I am var
```

Можливо на разі, ти не розумієш проблем, які буде створювати `var` і необхідності в блочному скоупі, але це розуміння прийде з досвідом.

### Scope Visibility 

Перш за все, мушу сказати одну річ, ти не можеш з зовні, доступатися до змінних які знаходяться в середині scope.

На прикладі покажу, що я маю на увазі:
```js
function test() {
  let hello = 'I am hello variable';
}

// Error. Ми отримаємо помилку, томущо в поточному скоупі такої
// змінної не має
console.log(hello);
```

На цьому прикладі в середині функції `test` ми створили змінну `hello`, і далі, вже за межами функції, тобто ззовні, ми намагаємося вивисети в консоль змінну `heelo`. Але ми отримаємо помилку, томущо змінна hello знаходиться в середині функції, і доступу туди з зовні в нас не має.

Ще один приклад;

```js
let animal = 'pig'

function test() {
  let animal = 'cow';
}

console.log(animal); // 'pig'
```

В даному прикладі, ми стоврили змінну `animal`, в яку ми запихнули слово "pig", а потім, ми створили змінну, з таким самим іменем в середині фукнції тест;

Якщо запустити цей код, то можна побачити, що в консолі нам виведеться слово 'pig'.

### Scope Chaining
Цей термін описує те, як шукається змінна між скоупами.

Приклад:

```js
let myAnimal = 'poni';

function parent() {
  
  function inner() {
     console.log(myAnimal);
  }
  
  inner();
}

parent();
```

Якщо запустити цей приклад, то в конослі ти побачиш, що виводиться "poni". Тепер розберемося як це все працює.

В нас є функція `parent`, всередені якої є ще одна функція `inner`, в якій ми виводимо в консоль змінну `myAnimal`. 

Коли ми намагаємося вивести цю змінню, спочатку, javascript шукає, чи в середині скоупа функції `inner` є змінна з такою назвою, в нашому випадку, такої змінною і функії `inner` не має, тому javascript йде по цепочці вверх по всім батьківським скоупам, аж до глобального. Батьківський скоуп для функції `inner` - це функція `parent`, тому javascript почне пошук змінної `myAnimal` в середині скоупу функційї `parent`, в нашому випадку такої змінної не має, тому рухаємся до батьківського скоупу функційї `parent`, батьківським скоупом для цієї функції біде глобальний скоуп. В глобальному скоупі ми знаходимо таку змінну і виводимо її в консолі.

Далі ще один приклад:

```js
let myAnimal = 'poni';

function parent() {
  let myAnimal = 'dog';
  
  function inner() {
     console.log(myAnimal);
  }
  
  inner();
}

parent();
```

Якщо запустити цей код, то в консолі в нас виведе 'dog', тому що javscript двигун, по ланцюгу батьківській скоупів, зміг знайти її в функції `parent`

І ще один приклад

```js
let myAnimal = 'poni';

function parent() {
  let myAnimal = 'dog';
  
  function inner() {
    let myAnimal = 'cat'
    console.log(myAnimal);
  }
  
  inner();
}

parent();
```

В даному прикладі в нас виведет 'cat', тому що javascript зміг знайти таку змінну, в тому самому скоупі, де і ми намагалися вивисте цю змінну, тобто в скоупі функції `inner`.
