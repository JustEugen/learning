# Array methods / Методи масиву
Одразу хочу попередити, що ця тема буде стосуватися не тільки масивів, а і функцій, тому вона буде доволі важкою.

Також хочу зазначити, що ми будемо часто використовувати слово метод, тому розберемо спочатку цей момент.

**Метод** - це властивість об'єкта, де в якості значення використовується функція.

```js
const user = {
  id: 10,
  sayHello: function() {
    console.log('hello')
  }
}
```

Перш за все, ти можеш бачити звичайний об'єкт, який має 2 властивості: `id` та `sayHello`. У властивості `id` ми зберігаємо число 10, а у властивості `sayHello` ми зберігаємо функцію, як ми і говорили раніше, якщо значення властивості функція, то це вже називається не властивість, а метод, отже `id` - це властивість об'єкта, а `sayHello` це метод об'єкта. 

Другий момент це те, що раніше коли ми розбирали функції, ми придумували для них ім'я, а тут в нас ім'я не має, чому так? По перше, властивості використовують окремий тип функцій, він називається `function expression` _(раніше ми розглядали `function declaration`)_, більш дедатальну різницю між ними, ми розберемо пізніше, на разі, їхня різниця в тому, що `function expression` не має назви, як і можна бачити на прикладі метода `sayHello`.

Для того щоб нам викликати нашу функцію, нам просто потрібно звернутися до метода, і виконати його

```js
const user = {
  id: 10,
  sayHello: function() {
    console.log('hello')
  }
}

user.sayHello(); // "hello"
```

Ми звертаємося до нашого методу, таким самим чином як і до властивостей, для прикладу:

```js
const user = {
  id: 10,
  address: {
    street: 'hi street',
    sayStreet: function() {
      console.log('my street is hi street')
    }
  }
}

user.address.sayStreet(); // 'my street is hi street'
```

Для початку ми звертаємося до властивості `address`, а потім в викликаємо метод `sayStreet`, який знаходиться в цій властивості

Також скажу, що `function expression` так само можуть приймати аргументи функції, так само як і `function declaration`

```js
const user = {
  name: "John",
  sayHiTo: function(hiTo) {
    console.log('John say hi to ', hiTo)
  }
}

user.sayHiTo(); // 'John say hi to '
```

## Методи для зміни масиву
Тепер поясню, чому те що ми розібрали вище важливо. Як я писав в темі про [масиви](./arrays.md), масив - це спеціальний тип об'єкта, який має певні властивості та методи. Масиви мають багато різних методів, які дозволяють працювати з ними

### Метод push()
З допомогою метода `push()` ми можемо додавати елемент в кінець масиву новий елемент.

```js
const products = ['apple', 'orange', 'beer', 'potato'];

products.push('kiwi');

console.log(products); // ['apple', 'orange', 'beer', 'potato', 'kiwi']
```

Як ти можеш бачити метод `push` додав в кінець масиву новий елемент зі значенням `kiwi`.

### Метод pop()
За допомогою метода `pop()` ти можеш видалити останній елемент масиву.

```js
const products = ['apple', 'orange', 'beer', 'potato'];

products.pop();

console.log(products); // ['apple', 'orange', 'beer']
```

Нам нічого не потрібно передавати в цей метод, він тільки видалить останній елемент масиву. 

### Метод unshift()
За допомогою метода `unshift()` ти можеш додати якийсь елемент в початок масиву

```js
const products = ['apple', 'orange', 'beer', 'potato'];

products.unshift('tomato');

console.log(products); // ['tomato', 'apple', 'orange', 'beer', 'potato']
```

Як ти можеш бачити, тепер найперший елемент в масиві не `apple`, а `tomato`.

### Метод shift()
За допомогою метода `shift()` ти можеш видалити перший елемент масиву.

```js
const products = ['apple', 'orange', 'beer', 'potato'];

products.shift();

console.log(products); // ['orange', 'beer', 'potato'']
```

Нам нічого не потрібно передавати в цей метод, він тільки видалить перший елемент масиву

## Callback functions / Функції зворотнього виклику
Це на справді важка тема, тому якщо не все буде зрозумілим, пиши мені в лс.

Якщо коротко, callback функції, це функції які ми передаємо в інші функції, і викликаємо в середині тих інших функціїй, для прикладу
```js
function test(callback) {
  const result = callback();
  
  console.log(result + 10);
}

test(function() {
  return 100
}); // 110
```

В результаті виконання цього коду, в результаті виведеться в консоль 110. Також хочу сказати, що сам по собі цей приклад безкорисним, йому не має застосування в реальному коді, але він пояснює деякі аспекти колбеків, більш детальні приклади, ми розберемо пізніше.

І так, що саме відбувається в нашому коді. Розберемо спочатку нашу функцію `test`. 

1. В якості першого аргумента, функція `test` приймає функцію
2. Після чого ми викликаємо функцію, яку ми отримали з колбеку, і результат виконання записуємо в константу `result`.
3. В кінці ми виводимо суму.

Тепер розберемо приклад в загальному:
1. Ми викликаємо функцію `test`, і передаємо в якості першого аргумента функцію. Мається на увазі цей код
```js
test(function() {
  return 100
}); // 110
```
2. Після чого в нас починається виконання нашої функцію `test()`. Мається на увазі цей код
```js
function test(callback) {
  const result = callback();
  
  console.log(result + 10);
}
```
3. По суті тут коли ми пишемо `callback()`, викликається функція з аргументів, тобто `function() { return 100 }` , ця функція поверне нам число 100, яке записується в константу `result'
4. Ми виводимо в консоль `result + 10`, тобто виходить 110

Окрім цього, цей приклад можна зробити ще важчим:
```js
function test(callback) {
  const result = callback(50);
  
  console.log(result + 10);
}

test(function(num) {
  return 100 + num
}); // 160
```

Якщо в попередньому прикладі, ми викликали просто `callback()`, в цьому ми викликаємо його з аргументами, а якщо точніше тільки з одним, з числом `50`. Тобто, тепер функція, яку ми передаємо при виклику функції `test` буде мати один аргумент.

