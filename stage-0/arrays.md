# Arrays / Масиви
Якщо робити аналогію з життям, то масиви ми використовуємо дуже і дуже часто, для прикладу книжка, з певної сторони її можна сприймати як масив сторінок, де кожна сторінка має свій номер, або список покупок, в якому товари йдуть в певному порядку один за одним.

Чому масиви це так необхідно в програмуванні? Уявимо, що наш додаток повинен зберігати списком продуктів, з того що ми вже знаємо, для того щоб зберігати данні, ми використовуємо змінні або константи.
```js
const product0 = 'apple';
const product1 = 'orange';
const product2 = 'beer';
const product3 = 'potato';
```
Тут ми зберігаємо 4 продукти, і для кожного продукту нам доводиться робити константу, але що робити у випадку якщо ми не знаємо скільки продуктів може бути в списку на покупки, або цей список може змінюватися, в один день це може бути 4, в інший 20, а в ще інший 2? А якщо ми захочемо зробити так, щоб користувач міг додавати продукти в реальному часі, як тоді їх зберігати?

Якраз для розв'язання таких проблем, і існують масиви, але спочатку трохи теорії.

Якщо в загальному, то масив - це **структура данних**, яка зберігає данні у вигляді списку, де кожний елемент списку має свій порядковий номер, починаючи з `0`, тобто, перший елемент буде мати номер `0`, другий елемент буде мати номер `1` і так по черзі.

**Javascript** доволі сильно відрізняється від інших мов програмування, і на відміну від інших мов, масив тут - це спеціальний вид об'єкта. Якщо говорити простіше, розробники `Javascript` створили тип данних `Object`, і на основі цього типу, вони створили спеціальний вид об'єкту як `Array` (масив) який по перше - перйняв весь функціонал об'єктів, по друге - на основі цього функціоналу додав свій, який спрощує нам роботу зі списками (під списком мається на увазі те, що ми розбирали на параграф вище).

На відміну від об'єктів де у якості ключа може бути `string` або `number`, в масивах у якості ключа може бути тільки `number`, **в масивах це число ми називаємо `index` (укр. індекс).**

> Ще раз повторю `index` - це просто порядковий номер елемента масиву від `0` до `n`. Перший елемент масиву буде мати індекс `0`, другий елемент індекс `1` і так далі.

Але тут треба розуміти, масив - це надбудова над об'єктом не на рівні мови, а на рівні самого Javascript рушія, тому масиви мають свій синтаксис створення.

> Коли я кажу "не на рівні мови" я маю на увазі, що використовуючи Javascript  ми не можемо повністю відтворити функціонал масивів, томущо деякі речі вписані в сам рушій, зі своєю лексикою створення і так далі.

Тут такий міні перерив. Те що було описано вище, це загальна теорія про масиви, яку насправді багато хто не знає, або не розуміє, деякі речі ти зараз не зрозумієш, але частково ми розберемо їх тут, частково в практиці.

Перша перевага масивів перед об'єктами, якщо нам потрібно працювати зі списками - це те, що масив автоматично проставляє індекс для кожного елементу масиву. Для прикладу, як би ми працювали зі списками, якщо використовували б звичайни об'єкт.
```js
const products = {
  0: 'apple',
  1: 'organe',
  2: 'berer',
  3: 'potato'
}
```
Ось ми створили об'єкт, де кожний продукт, має свій номер. Виведемо кожний продукт в консоль. Щоб вивести властивість об'єкта, в якого у якості ключа `number`, ми повинні використовувати квадратні дужки `[]`
```js
const products = {
  0: 'apple',
  1: 'organe',
  2: 'berer',
  3: 'potato'
}

console.log(products[0]); // 'apple'
console.log(products[1]); // 'orange'
console.log(products[2]); // 'beer'
console.log(products[3]); // 'potato'
```

Перша важкість, яку я бачу це те, що ми повинні самі проставляти порядковий номер для кожної властивості, типу, тут в нас 4 елементи, це не так багато, але що якщо в нас буде 100 елементів?.

Масиви ж, спрощують нам цю роботу, для початку розберемося як створювати масив.

Щоб створити масив, ми спочатку оголошуємо `const` або `let`, далі після оператора присвоєння `=` відкриваємо квадратні дужки `[]`. Елементи масиву ми перераховуємо через кому `,`.

**Ось приклад масиву з `4` елементів:**
```js
const products = ['apple', 'orange', 'beer', 'potato'];
```
Як можеш бачити між кожним елементом ми ставимо кому `,`.

**А ось масив з одним елементом:**
```js
const products = ['tomato'];
```
**А ось пустий масив:**
```js
const products = [];
```

## Індекси
Перша проблема яку ми знайшли - це те, що використовуючи звичайний об'єкт нам самим треба проставляти порядковий номер, а масиви це роблять самі.
```js
                     0        1        2        3
const products = ['apple', 'orange', 'beer', 'potato'];
```
В цьому масиві в нас є 4 елементи:
- Для 1-го елемента буде присвоєний індекс / ключ `0` і значення - `apple`
- Для 2-го елемента буде присвоєний індекс / ключ `1` і значення - `orange`
- Для 3-го елемента буде присвоєний індекс / ключ `2` і значення - `beer`
- Для 4-го елемента буде присвоєний індекс / ключ `2` і значення - `potato`

Як я і казав, масив це просто надбудова над об'єктом, індекс в масиві / порядковий номер - це те ж саме що і ключ в об'єкті, тому виводиться це все таким самим чином як в прикладі з об'єктом
```js
                     0        1        2        3
const products = ['apple', 'orange', 'beer', 'potato'];

console.log(products[0]); // 'apple'
console.log(products[1]); // 'orange'
console.log(products[2]); // 'beer'
console.log(products[3]); // 'potato'
```

Ти вже можеш бачити величезну різницю в тому як би нам довелося заморочуватися з індексами якщо ми б використовували об'єкти для роботи зі списками, нам довелося б контролювати їх своїми руками, а у випадку з масивами, ми просто перелічуємо через кому елементи які ми хочемо зберігати, а воно вже саме проставить індекси.

## Доступ до не існуючих елементів
Якщо ти пам'ятаєш, коли ми намагалися вивести властивість об'єкта, якої не існує в цьому об'єкті, то ми отримували `undefined`.
```js
const o = {
  name: 'John'
}

console.log(o.name); // 'John'
console.log(o.age); // undefined
```
Так як масиви - це те ж саме що й об'єкти, якщо ти будеш намагатися отримати не існуючи елемент масиву, ти також отримаєш `undefined`.
```js
const products = ['apple', 'orange', 'beer', 'potato'];

console.log(products[4]); // undefined
console.log(products[5]); // undefined
console.log(products[6]); // undefined
console.log(products[7]); // undefined
```
В масиві `products` `4` елементи, і найбільший індекс - це `3` _(3 а не 4, тому що ми рахуємо індекси з 0)_, а якщо ти будеш звертатися до індексу `4` і більше, ти по суті будеш звертатися до властивостей об'єкта яких не існує, тому ти також отримуєш `undefined`

## Що ми можемо зберігати в середині масиву?
Так як масив це всього лиш надбудова над об'єктом тут діють ті ж самі правила. В об'єкті, ми могли зберігати будь-який тип данних, так і тут так само.
```js
                     0     1    2        3           4             5            6          7
const products = ['apple', 10, null, { age: 10 }, undefined, function hi() {}, true, ['orange', 938]];

console.log(products[0]); // 'apple'
console.log(products[1]); // 10
console.log(products[2]); // null
console.log(products[3]); // { age: 10 }
console.log(products[4]); // undefined
console.log(products[5]); // function hi() {}
console.log(products[6]); // true
console.log(products[7]); // ['orange', 938]

// і тут трохи цікавіше, якщо пам'ятаєш, ми в темі про об'єкти розглядали вкладені об'єкти
// якщо ніт, то краще візь і кинь оком саме на ту під тему
// тут така ж сама фігня, масив - це об'єкт, і тут в нас виходить така ж сама ситуація
// спочатку ми доступаємося до останнього елемента масива products використовуючи products[8]
// в середині products[8] також масив, і так само як ми доступалися до елемнетів масива products
// ми доступаємося і до елементів масива що лежить тут products[8]
console.log(products[8][0]); // 'organge'
console.log(products[8][1]); // 938'
```
## Довжина масиву
Тут ми ще ближче підбираємося до відповіді, чому для списків використовувати об'єкти це погана ідея, і чому існує така штука як масив.

От уявимо що в нас не має масивів, а є тільки об'єкти, і в об'єкті мм зберігаємо список продуктів, і нам треба мати можливість дізнатися скільки в загальному продуктів знаходиться в цьому списку. В об'єктах, не має функціоналу, який дозволяє тобі отримати кількість властивостей, потрібно перебрати весь об'єкт і рахувати (як перебирати об'єкт ми потім розглянемо), але от уяви що в тебе в об'єкті дуже багато продуктів, і перебирато його кожного разу, як ти хочеш дізнатися кілкість продуктів не найкраще рішення, так як буде негативно впливати на швидкість.

Як варіант ми можемо зберігати додаткову властивість, назвемо її `count`, і в неї будемо вписувати загальну кількість продуктів

```js
const products = {
  0: 'apple',
  1: 'organe',
  2: 'berer',
  3: 'potato',
  count: 4
}
```
Але є одна біда, якщо ми будемо міняти цей об'єкт, наприклад додамо ще один продукт, нам треба буде вручну міняти цю властивість `count`.

```js
const products = {
  0: 'apple',
  1: 'organe',
  2: 'berer',
  3: 'potato',
  count: 4
}

products[4] = 'kiwi'
products.count = products.count + 1;
```

Я думаю ти бачиш, що це прям дуже незручно, і можна легко провтикати, і купа інших нюансів.

Крутизна масивів в тому, що якщо ти додаєш елемент, чи забираєш, він по перше, автоматично міняє його дожину, по друге, якщо ти наприклад видалиш елемент з індексом `0`, то використовуючи об'єкт тобі треба буде зменшити індекс всіх наступних елементів на 1, а от масив зробить це сам.


**Перш за все, як отримати довжину масиву?**

Так як масив - це надбудова над об'єктом, він має вбудовані властивості, один з них - це `length`, в ньому зберігається довжина масива

```js
const products = ['apple', 'orange', 'beer', 'potato'];

console.log(products.length); // 4
```

А для того, щоб, наприклад додати в кінець масиву елемент, в масивів існує є метод `push`. Він приймає один аргумент - це значення яке ти хочеш впихнути в кінець масива

> Метод - це просто властивість, де в якості значення використовується функція
> ```js
> const user = {
>   firstName: "John",
>   lastName: "Carter",
>   getFullName: function() {
>     return 'John Carter';
>   }
> ```
> Як можеш бачити, тут є властивість `firstName`, `lastName` і метод `getFullName` - функція що повертає повне ім'я

```js
const products = ['apple', 'orange', 'beer', 'potato'];

console.log(products.length); // 4

products.push('kiwi');

console.log(products.length); // 5
console.log(products[4]); // kiwi
console.log(products); // ['apple', 'orange', 'beer', 'potato', 'kiwi']
```

Як ти можеш бачити метод `push` додав в кінець масиву елемент, надав для нього потрібний індекс, тобто `4` (так як перед тим як ми додали цей елемент, в масиві в нас було всього лиш 4 елементи, тобто останній індекс був 3, а коли в масиві стало 5 елементів, останній індекс має бути 4), і оновив довжину масиву, тобто властивість `length`

## Додання елементів масиву напряму
Тут знову повторюся, масиви - це просто надбудова над об'єктами, тому тут діє теж саме правило що і з об'єктами.

Якщо в об'єкт нам потрібно додати властивість, ми це робили наступним чином:
```js
const o = {
  name: 'John Carter'
}

o.age = 10;

console.log(o); // { name: 'John Carter', age: 10 }
```

З масивами ми робимо те ж саме:
```js
const products = [];

products[0] = 'apple';

console.log(products); // ['apple']
```

Але в масивах є одна цікава штука, якщо в тебе є пустий масив, і ти хочеш встановити елемент не на `0` позицію, тобто самий перший елемент, а встановити значення 10 елемента, тобто позицію `9` (так як рахуємо від `0`), то тоді для позицій `0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8` - автоматично буде встановленно значення `undefined`:

```js
const products = [];

products[9] = 'apple';

console.log(products.length); // 10

console.log(products[0]); // undefined
console.log(products[1]); // undefined
console.log(products[2]); // undefined
console.log(products[3]); // undefined
console.log(products[4]); // undefined
console.log(products[5]); // undefined
console.log(products[6]); // undefined
console.log(products[7]); // undefined
console.log(products[8]); // undefined
console.log(products[9]); // 'apple'

```

## Значення по посиланню
Так як масив це по суті об'єкт, він також є значенням по посиланню (ми це розглядали в темі про об'єкти, але я тут також наведу приклади).

```js
const productsA = ['apple', 'kiwi'];

const productsB = productsA;

productsB[1] = 'changed';
productsB[2] = 'new one';

console.log(productsB); // ['apple', 'changed', 'new one'];
console.log(productsA); // ['apple', 'changed', 'new one'];
```

Томущо коли ми створюємо об'єкт (productsA) (масиви це по суті і є об'єкт, тому я одразу кажу об'єкт), він створюється десьв пам'яті, а в нашу змінну чи константу записується посилання на цей об'єкт, і получається так, що для константи `productB` ми присвоюємо не сам масив, а посилання на цей масив, тому і виходить так, що `productsA` і `productsB` працюють з одним і тим самим масивом, так як в них посилання на один і той самий масив

## Перебирання масивів
Масиви дуже легко перебирати за допомогою циклів. Уявимо ситуацію, в нас є масив продуктів, і кожний продукт нам треба вивести в консоль
```js
const products = ['apple', 'orange', 'beer', 'potato'];

for(let index = 0; index < products.length; index = index + 1) {
  console.log(products[index])
}
```

Якщо зайти в консоль, то ти побачиш що в нас було виведено 4 продукти з нашого масиву, але давай розберемо це детальніше.

1. Ми створюємо наш `for`
2. На початку ми створємо змінну `index`
3. В якості умови ми пишемо, що цикл буде працювати до тих пір, поки `index` буде менший ніж довжина нашого масиву, тобто в нашому випадку це 3
4. Після кожної ітерації ми до індексу додаємо число `1`

Я хочу трохи зупинитися на тому, як ми будемо використовувати нашу змінну `index`. Це доволі загальний приклад, який ти не раз ще будеш бачити в практиці і використовувати. Його суть в тому, що ми створюємо змінну, яка буде репрезентувати індекс поточного елемента масива, зверни увагу на `console.log` ми виводимо там `products[index]`.

І якщо розбирати ітерації, як це виглядатиме:
1. На першу інтеграцію, `index` в нас буде мати значення `0` і ми будемо виводити перший елемент масиву, після закінчення ітерації ми додамо одиницю, щоб в наступній ітерації, ми вже доступалися до наступного елемента масиву
2. На другу ітерацію, `index` в нас буде мати значення `1` і ми виведемо другий елемент масиву, і знову додамо до `index` одиницю
3. На третю ітерацію, `index` в нас буде мати значення `2`, і ми виведемо третій елемент масиву
4. На четверту ітерацію, `index` в нас буде мати значення `3` і ми виведемо четвертий елемент масиву

Якщо би наприклад, тобі треба було би перебрати масив не з першого елемента, а з третього, тобі би замість `index = 0` потрібно було би просто поставити `index = 2`

```js
const products = ['apple', 'orange', 'beer', 'potato'];

for(let index = 2; index < products.length; index = index + 1) {
  console.log(products[index])
}
```

Тоді в такому випадку ти виведеш тільки `beer` і `potato`

Масиви, як і об'єкти круті тим, що до них доступ дуже і дуже швидкий, що я маю на увазі. Якщо ти знаєш `index` елемента, якщо говорити про масиви, або `ключ` об'єкта, якщо говорити про об'єкти, ти можеш використати їх щоб доступитися напряму, до конкретного елемента, чи конкретної властивості. Тобто тобі не треба проходитися по всьому об'єкті чи по всьому масиві, щоб знайти чи щось дістати.
