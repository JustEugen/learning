# Git

Git - це система контролю версій (VCS - version control system), він забезпечує:
- Ефективну роботу в команді;
- Гарантію того, що якщо з твоїм девайсом щось станеться, ти не втратиш проект;
- Історію змін, в будь-який момент, в тебе є можливість подивитися що змінювалося, коли змінювалося і ким;

> Тут важлива інфа, git замість того щоб зберігати поточну версію твого проєкту, які тут є файлики чи папочки, зберігає історію змін, і вже базуючись на історії змін, він відтворює вигляд твого проєкту.

### Основні поняття:
- **Repository** - це спеціальна папочка яка є в кожному проекті, що використовує git, вона називається .git, і в ній знаходиться історія всіх змін, і по суті вся інформація про твій проект;
- **Github** - це хмарна платформа для зберігання твоїх репозиторіїв, окрім цього він надає багато нових можливостей, для роботи в команді;
- **Clone** - клонування це грубо кажучи скачування от тієї папочки .git, наприклад з Github. Клонування - це один з функціоналу git, після того як воно скачає історію всіх змін, воно автоматично відтворить потрібну файлову структуру;
- **Commit** - іншими словами це знімок змін, як я і казав, git збергіає історію змін, а кожна зміна зберігається в commit`і;
- **Push & Pull** - push - відправити зміни на хмарку, pull - дістати зміни з хмарки. Уяви ситуацію, ти працюєш над якимось функціоналом, зробив якусь його частину, і в тебе закінчився робочий день, ти можеш нічого не робити, але що, якщо в тебе вночі, щось станеться з ноутбуком, згорить наприклад, то тоді ти втратиш всі свої зміни. Git надає дуже зручний інтерфейс роботи з ним, з допомогою спеціальних команд, ти з легкістю можеш відправити свої зміни в хмарку, або як ми кажемо - запушити, і ти будеш впевненний, що твій проект в безпеці. Також уяви, що ти парцюєш на проекті не сам, твій колега зробив якийсь функціонал, і відправив його на хмарку. Для того щоб отримати тобі треба просто використати спеціальну команду pull, або як ми кажемо зпулити зміни. 
- **Branch** - гілка. Одна з основних переваг Git - це робота в команді, і для того щоб зробити цю роботу максимально зручною, потрібно зробити так, щоб розробники не заважали один одному. Для цього і була придумана система гілок. Перш за все, в git завжди є одна головна гілка, яка не може бути видалена, її назва main, або master. Тепер уяви ситуацію, що в тебе є тільки от одна ця гілка, і в тебе 10 розробників, кожний, в 6 годині вечора закінчує працювати і відправляє свої зміни на хмарку, в цю саму гілку, що тоді станеться? А станеться конфлікт, ти ж по суті відправив в хмарку зміни, для того щоб не втратити їх, можливо код, який ти відправив, навіть не працює, або ти щось написав тимчасове, або ті зміни які зробив ти, затрунуть ще чиїсь зміни, а в тебе 10 таких розробників, і получається повний хаос. Що ж дає нам зробити git, кожний девелопер, коли отримує задачу, створює собі свою, власну гілку для цієї задачі, ми це називаємо відбречуватися, і тепер, кожинй девелопер, в 6 годині вечора, буде відправляти ці зміни не в загальну для всіх, головну гілку, а в свою особисту, нікому не мішаючи, і працюючи над задачою стільки, скільки йому треба. А коли він доробить свою задачу, він злегкістю закине зміни зі своєї гілки, в master (це наступна тема)
- **Merge** - це просес вливання змін з однієї гілки, в іншу, детальніше ми розглянемо на прикладх
- **Remote** - ця тема доповнює попередню про push і pull. І от тут питання, коли ми відправляємо зміни в хмарку, чи навпаки підтягуємо їх собі, як git розуміє, де вони взагалі знаходяться. Адреса нашого репозиторію зберігається в середині штуки під назвою remote, варто сказати, що насправді, в проекті може бути декілька remote (особисто я з таким не стикався, але це можливо), а отже кожен remote повинен мати ім’я, за замовчуванням, після того як ти зклонив проект, завжди буде один єдиний remote під назвою origin, який буде вказувати на адресу, з якої ти клонив проект. Коли ти пушиш, чи пулиш проект, в тебе є можливість казати ремоут, з яким ти будеш працювати, якщо ти не вказуєш ремоут, буде використовуватися ремоут з назвою origin

### Список команд які часто використовуються
- `git status` - дізнатися на якій ти гілці, які файли були змінені, скільки було створено комітів
- `git add --all` - додати всі зміни в статус tracked
- `git branch <your_branch_name>` - стоврити гілку
- `git checkout <your_branch_name>` - переключитися на гілку
- `git checkout -b <your_branch_name>` - стоврити гілку і одразу переключитися на неї
- `git commit -m "<your_commit_message>"` - створити коміт
- `git push` - відправити зміни на хмарку
- `git pull` - дістати зміни з хмарки
- `git push --set-upstream <your_branch_name>` - відправити гілку в хмарку *потрібно робити тільки раз, для новостворенної гілки* 
- `git fetch --all` - дістати всю інформацію з хмарки. Наприклад, якщо хтось створив гілку, і відправив її в хмарку, в тебе її не буде, а з допомогою цієї команди ти зможеш це все отимати

### Туторіал
Спочатку заходимо в Github, і створюємо репозиторій, обов'язаково натискаємо на галочку, створити Readme.md

Для прикладу я створив репозиторій і назвав його poniland. Далі я повинен зклонувати його собі на мій ноутбук, щоб почати працювати над ним.
```
$ git clone git@github.com:JustEugen/poniland.git
```

Уявимо що в нас є задача - створити форму реєстрації, як ми і говорили раніше, коли ми починаємо працювати над якимось функціоналом, ми повинні створювати для себе окрему гілку.
```
$ git branch create_registration_form   // стоворили гілку
$ git checkout create_registration_form // переключилися на цю гілку

або, можна використати лише одну команду

$ git checkout -b create_registration_form // створити гілку, і одразу переключитися на неї
```

Коли ми стоврюємо гілки, вони створюються тільки локально на нашому комп'ютері, якщо нам потрібно, а нам потрібно, щоб ця гілка була в хмарці, нам потрібно виконати наступну команду

```
$ git push --set-upstream origin create_registration_form
```

Тепер ця гілка існує в нас і в хмарці.

Почнемо реалізовувати наш функціонал. Створимо пустий файл index.html, і уявимо, що ми там вже щось написали, і зробили частину нашої задачі. Для наглядності можна написати там якусь абракадабру.

Для того щоб перевірити, що було змінено, існує команда
```
$ git status
```

Тепер нам потрібно відправити ці зміни в хмарку, але для цього нам потрібно розібратися з 2 новими поняттями - це `Untracked files` і `Tracked files`. `Untracked files` - це файли які були змінені, вони позначаються червоним кольором,`Tracked files` - це файли які були змінені, і ми це зафіксували, вони позначаються зеленим кольором.

Для того щоб зафіксувати ці зміни, нам потрібно зробити наступне
```
$ git add --all
```

За допомогою цієї команди ми позначаємо всі змінені, як зафіксовані. Як говорилося раніше, всі зміни повинні знаходитися в середині комітів, і відправляємо ми на хмарку зміни, які огорнуті в коміти. Для того щоб створити коміт:

```
$ git commit -m “Added index.html file”
```

Швиденько розберемо цю команду. `git commit` - створити commit, `-m “some text here”` - додати commit message, грубо кажучи, коли ти будеш дивитися історію комітів, там буде писатися то що ти запихнув в ці лапки.

Ми можемо перевірити чи справді коміт був створений за допомогою команди `git status`.

Після чого ми можемо відправити цей коміт в хмарку за допомого команди 
```
$ git push
```

Уявимо що ми закінчили працювати над нашою задчею, і тепер нам потрібно залити всі зміни які ми зробили в головну гілку проекту main. Для цього ми використовуємо спеціальну команду `merge`.

Зараз ми знаходимося на гілці `create_registration_form` і її треба влити в `main`, для цього робимо наступне:
```
$ git checkout main // переключаємося на гілку, в яку ми хочемо вливати інші гілки
$ git merge create_registration_form // влити в нашу поточну гілку (це вже є main) гілку create_registration_form
$ git push // відправити всі зміни на гілці main в хмарку
```



_

_

_

_

_

_

_

_

_

_

_

_

_

_

_

_

_

_

_

_

_

_
